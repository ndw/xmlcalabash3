package com.xmlcalabash.xslt

import com.xmlcalabash.util.SaxonTreeBuilder
import net.sf.saxon.event.ReceiverOption
import net.sf.saxon.om.*
import net.sf.saxon.s9api.QName
import net.sf.saxon.s9api.XdmNode
import net.sf.saxon.type.BuiltInAtomicType
import java.net.URI

interface XsltElementInterface {
    fun render(builder: SaxonTreeBuilder)
}

class XsltTextElement(val text: String) : XsltElementInterface {
    override fun render(builder: SaxonTreeBuilder) {
        builder.addText(text)
    }
}

@DslMarker
annotation class XsltTagMarker

@XsltTagMarker
abstract class XsltTag(val prefix: String, val namespace: String, val localName: String) : XsltElementInterface {
    val name = QName(prefix, namespace, localName)
    val children = arrayListOf<XsltElementInterface>()
    val attributes = hashMapOf<QName, String>()
    val namespaces = hashMapOf<String, String>()

    protected fun <T: XsltElementInterface> initTag(tag: T, init: T.() -> Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }

    override fun render(builder: SaxonTreeBuilder) {
        builder.addStartElement(name, attributeMap(), namespaceMap())
        for (c in children) {
            c.render(builder)
        }
        builder.addEndElement()
    }

    fun maybe(name: String, value: String?) {
        if (value != null) {
            attributes[QName(name)] = value
        }
    }

    fun maybe(name: String, value: Boolean?) {
        if (value != null) {
            attributes[QName(name)] = value.toString()
        }
    }

    private fun attributeMap(): AttributeMap {
        var attrs: AttributeMap = EmptyAttributeMap.getInstance()
        for ((name, value) in attributes) {
            attrs = attrs.put(
                AttributeInfo(
                FingerprintedQName(name.prefix, name.namespaceUri, name.localName),
                BuiltInAtomicType.UNTYPED_ATOMIC,
                value,
                null,
                ReceiverOption.NONE
            )
            )
        }
        return attrs
    }

    private fun namespaceMap(): NamespaceMap {
        var nsmap = NamespaceMap.emptyMap()
        for ((prefix, uri) in namespaces) {
            nsmap = nsmap.put(prefix, NamespaceUri.of(uri))
        }
        nsmap = nsmap.put(prefix, NamespaceUri.of(namespace))
        return nsmap
    }
}
class XsltPackage(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "package")


class XsltUsePackage(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "use-package")


class XsltExpose(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "expose")


class XsltAccept(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "accept")


class XsltOverride(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "override")


class XsltStylesheet(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "stylesheet") {
    fun usePackage(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String? = null,
        packageVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltUsePackage.() -> Unit) {
        val tag = initTag(XsltUsePackage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("name", name)
        tag.maybe("package-version", packageVersion)
    }
    fun include(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltInclude.() -> Unit) {
        val tag = initTag(XsltInclude(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("href", href)
    }
    fun import(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltImport.() -> Unit) {
        val tag = initTag(XsltImport(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
    }
    fun importSchema(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        namespace: String? = null,
        schemaLocation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltImportSchema.() -> Unit) {
        val tag = initTag(XsltImportSchema(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("namespace", namespace)
        tag.maybe("schema-location", schemaLocation)
    }
    fun stripSpace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        elements: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltStripSpace.() -> Unit) {
        val tag = initTag(XsltStripSpace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("elements")] = elements
    }
    fun preserveSpace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        elements: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPreserveSpace.() -> Unit) {
        val tag = initTag(XsltPreserveSpace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("elements")] = elements
    }
    fun decimalFormat(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String? = null,
        decimalSeparator: String? = null,
        groupingSeparator: String? = null,
        infinity: String? = null,
        minusSign: String? = null,
        exponentSeparator: String? = null,
        NaN: String? = null,
        percent: String? = null,
        perMille: String? = null,
        zeroDigit: String? = null,
        digit: String? = null,
        patternSeparator: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDecimalFormat.() -> Unit) {
        val tag = initTag(XsltDecimalFormat(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("name", name)
        tag.maybe("decimal-separator", decimalSeparator)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("infinity", infinity)
        tag.maybe("minus-sign", minusSign)
        tag.maybe("exponent-separator", exponentSeparator)
        tag.maybe("NaN", NaN)
        tag.maybe("percent", percent)
        tag.maybe("per-mille", perMille)
        tag.maybe("zero-digit", zeroDigit)
        tag.maybe("digit", digit)
        tag.maybe("pattern-separator", patternSeparator)
    }
    fun template(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        match: String? = null,
        name: String? = null,
        priority: String? = null,
        mode: String? = null,
        `as`: String? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTemplate.() -> Unit) {
        val tag = initTag(XsltTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("match", match)
        tag.maybe("name", name)
        tag.maybe("priority", priority)
        tag.maybe("mode", mode)
        tag.maybe("as", `as`)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun mode(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String? = null,
        streamable: Boolean? = null,
        onNoMatch: String? = null,
        onMultipleMatch: String? = null,
        warningOnNoMatch: Boolean? = null,
        warningOnMultipleMatch: Boolean? = null,
        typed: Boolean? = null,
        visibility: String? = null,
        useAccumulators: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMode.() -> Unit) {
        val tag = initTag(XsltMode(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("name", name)
        tag.maybe("streamable", streamable)
        if (onNoMatch != null
            && onNoMatch != "deep-copy"
            && onNoMatch != "shallow-copy"
            && onNoMatch != "deep-skip"
            && onNoMatch != "shallow-skip"
            && onNoMatch != "text-only-copy"
            && onNoMatch != "fail") {
            throw RuntimeException("Invalid onNoMatch: $onNoMatch")
        }
        tag.maybe("on-no-match", onNoMatch)
        if (onMultipleMatch != null
            && onMultipleMatch != "use-last"
            && onMultipleMatch != "fail") {
            throw RuntimeException("Invalid onMultipleMatch: $onMultipleMatch")
        }
        tag.maybe("on-multiple-match", onMultipleMatch)
        tag.maybe("warning-on-no-match", warningOnNoMatch)
        tag.maybe("warning-on-multiple-match", warningOnMultipleMatch)
        tag.maybe("typed", typed)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
        tag.maybe("use-accumulators", useAccumulators)
    }
    fun globalContextItem(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        `as`: String? = null,
        use: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltGlobalContextItem.() -> Unit) {
        val tag = initTag(XsltGlobalContextItem(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("as", `as`)
        if (use != null
            && use != "required"
            && use != "optional"
            && use != "absent") {
            throw RuntimeException("Invalid use: $use")
        }
        tag.maybe("use", use)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun param(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        required: Boolean? = null,
        tunnel: Boolean? = null,
        static: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltParam.() -> Unit) {
        val tag = initTag(XsltParam(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("required", required)
        tag.maybe("tunnel", tunnel)
        tag.maybe("static", static)
    }
    fun attributeSet(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        useAttributeSets: String? = null,
        visibility: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttributeSet.() -> Unit) {
        val tag = initTag(XsltAttributeSet(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("use-attribute-sets", useAttributeSets)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
        tag.maybe("streamable", streamable)
    }
    fun function(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        `as`: String? = null,
        visibility: String? = null,
        streamability: String? = null,
        overrideExtensionFunction: Boolean? = null,
        override: Boolean? = null,
        newEachTime: Boolean? = null,
        cache: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFunction.() -> Unit) {
        val tag = initTag(XsltFunction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("as", `as`)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
        tag.maybe("streamability", streamability)
        tag.maybe("override-extension-function", overrideExtensionFunction)
        tag.maybe("override", override)
        tag.maybe("new-each-time", newEachTime)
        tag.maybe("cache", cache)
    }
    fun namespaceAlias(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        stylesheetPrefix: String,
        resultPrefix: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespaceAlias.() -> Unit) {
        val tag = initTag(XsltNamespaceAlias(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("stylesheet-prefix")] = stylesheetPrefix
        tag.attributes[QName("result-prefix")] = resultPrefix
    }
    fun accumulator(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        initialValue: String,
        `as`: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAccumulator.() -> Unit) {
        val tag = initTag(XsltAccumulator(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.attributes[QName("initial-value")] = initialValue
        tag.maybe("as", `as`)
        tag.maybe("streamable", streamable)
    }
    fun key(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        match: String,
        use: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltKey.() -> Unit) {
        val tag = initTag(XsltKey(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.attributes[QName("match")] = match
        tag.maybe("use", use)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun output(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String? = null,
        method: String? = null,
        allowDuplicateNames: Boolean? = null,
        buildTree: Boolean? = null,
        byteOrderMark: Boolean? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: Boolean? = null,
        htmlVersion: String? = null,
        includeContentType: Boolean? = null,
        indent: Boolean? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: Boolean? = null,
        parameterDocument: String? = null,
        standalone: Boolean? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: Boolean? = null,
        useCharacterMaps: String? = null,
        version: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOutput.() -> Unit) {
        val tag = initTag(XsltOutput(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("name", name)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("version", version)
    }
    fun characterMap(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        useCharacterMaps: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCharacterMap.() -> Unit) {
        val tag = initTag(XsltCharacterMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("use-character-maps", useCharacterMaps)
    }
}


class XsltTransform(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "transform") {
    fun usePackage(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String? = null,
        packageVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltUsePackage.() -> Unit) {
        val tag = initTag(XsltUsePackage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("name", name)
        tag.maybe("package-version", packageVersion)
    }
    fun include(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltInclude.() -> Unit) {
        val tag = initTag(XsltInclude(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("href", href)
    }
    fun import(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltImport.() -> Unit) {
        val tag = initTag(XsltImport(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
    }
    fun importSchema(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        namespace: String? = null,
        schemaLocation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltImportSchema.() -> Unit) {
        val tag = initTag(XsltImportSchema(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("namespace", namespace)
        tag.maybe("schema-location", schemaLocation)
    }
    fun stripSpace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        elements: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltStripSpace.() -> Unit) {
        val tag = initTag(XsltStripSpace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("elements")] = elements
    }
    fun preserveSpace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        elements: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPreserveSpace.() -> Unit) {
        val tag = initTag(XsltPreserveSpace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("elements")] = elements
    }
    fun decimalFormat(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String? = null,
        decimalSeparator: String? = null,
        groupingSeparator: String? = null,
        infinity: String? = null,
        minusSign: String? = null,
        exponentSeparator: String? = null,
        NaN: String? = null,
        percent: String? = null,
        perMille: String? = null,
        zeroDigit: String? = null,
        digit: String? = null,
        patternSeparator: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDecimalFormat.() -> Unit) {
        val tag = initTag(XsltDecimalFormat(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("name", name)
        tag.maybe("decimal-separator", decimalSeparator)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("infinity", infinity)
        tag.maybe("minus-sign", minusSign)
        tag.maybe("exponent-separator", exponentSeparator)
        tag.maybe("NaN", NaN)
        tag.maybe("percent", percent)
        tag.maybe("per-mille", perMille)
        tag.maybe("zero-digit", zeroDigit)
        tag.maybe("digit", digit)
        tag.maybe("pattern-separator", patternSeparator)
    }
    fun template(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        match: String? = null,
        name: String? = null,
        priority: String? = null,
        mode: String? = null,
        `as`: String? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTemplate.() -> Unit) {
        val tag = initTag(XsltTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("match", match)
        tag.maybe("name", name)
        tag.maybe("priority", priority)
        tag.maybe("mode", mode)
        tag.maybe("as", `as`)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun mode(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String? = null,
        streamable: Boolean? = null,
        onNoMatch: String? = null,
        onMultipleMatch: String? = null,
        warningOnNoMatch: Boolean? = null,
        warningOnMultipleMatch: Boolean? = null,
        typed: Boolean? = null,
        visibility: String? = null,
        useAccumulators: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMode.() -> Unit) {
        val tag = initTag(XsltMode(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("name", name)
        tag.maybe("streamable", streamable)
        if (onNoMatch != null
            && onNoMatch != "deep-copy"
            && onNoMatch != "shallow-copy"
            && onNoMatch != "deep-skip"
            && onNoMatch != "shallow-skip"
            && onNoMatch != "text-only-copy"
            && onNoMatch != "fail") {
            throw RuntimeException("Invalid onNoMatch: $onNoMatch")
        }
        tag.maybe("on-no-match", onNoMatch)
        if (onMultipleMatch != null
            && onMultipleMatch != "use-last"
            && onMultipleMatch != "fail") {
            throw RuntimeException("Invalid onMultipleMatch: $onMultipleMatch")
        }
        tag.maybe("on-multiple-match", onMultipleMatch)
        tag.maybe("warning-on-no-match", warningOnNoMatch)
        tag.maybe("warning-on-multiple-match", warningOnMultipleMatch)
        tag.maybe("typed", typed)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
        tag.maybe("use-accumulators", useAccumulators)
    }
    fun globalContextItem(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        `as`: String? = null,
        use: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltGlobalContextItem.() -> Unit) {
        val tag = initTag(XsltGlobalContextItem(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("as", `as`)
        if (use != null
            && use != "required"
            && use != "optional"
            && use != "absent") {
            throw RuntimeException("Invalid use: $use")
        }
        tag.maybe("use", use)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun param(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        required: Boolean? = null,
        tunnel: Boolean? = null,
        static: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltParam.() -> Unit) {
        val tag = initTag(XsltParam(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("required", required)
        tag.maybe("tunnel", tunnel)
        tag.maybe("static", static)
    }
    fun attributeSet(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        useAttributeSets: String? = null,
        visibility: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttributeSet.() -> Unit) {
        val tag = initTag(XsltAttributeSet(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("use-attribute-sets", useAttributeSets)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
        tag.maybe("streamable", streamable)
    }
    fun function(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        `as`: String? = null,
        visibility: String? = null,
        streamability: String? = null,
        overrideExtensionFunction: Boolean? = null,
        override: Boolean? = null,
        newEachTime: Boolean? = null,
        cache: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFunction.() -> Unit) {
        val tag = initTag(XsltFunction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("as", `as`)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
        tag.maybe("streamability", streamability)
        tag.maybe("override-extension-function", overrideExtensionFunction)
        tag.maybe("override", override)
        tag.maybe("new-each-time", newEachTime)
        tag.maybe("cache", cache)
    }
    fun namespaceAlias(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        stylesheetPrefix: String,
        resultPrefix: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespaceAlias.() -> Unit) {
        val tag = initTag(XsltNamespaceAlias(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("stylesheet-prefix")] = stylesheetPrefix
        tag.attributes[QName("result-prefix")] = resultPrefix
    }
    fun accumulator(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        initialValue: String,
        `as`: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAccumulator.() -> Unit) {
        val tag = initTag(XsltAccumulator(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.attributes[QName("initial-value")] = initialValue
        tag.maybe("as", `as`)
        tag.maybe("streamable", streamable)
    }
    fun key(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        match: String,
        use: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltKey.() -> Unit) {
        val tag = initTag(XsltKey(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.attributes[QName("match")] = match
        tag.maybe("use", use)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun output(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String? = null,
        method: String? = null,
        allowDuplicateNames: Boolean? = null,
        buildTree: Boolean? = null,
        byteOrderMark: Boolean? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: Boolean? = null,
        htmlVersion: String? = null,
        includeContentType: Boolean? = null,
        indent: Boolean? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: Boolean? = null,
        parameterDocument: String? = null,
        standalone: Boolean? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: Boolean? = null,
        useCharacterMaps: String? = null,
        version: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOutput.() -> Unit) {
        val tag = initTag(XsltOutput(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("name", name)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("version", version)
    }
    fun characterMap(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        useCharacterMaps: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCharacterMap.() -> Unit) {
        val tag = initTag(XsltCharacterMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("use-character-maps", useCharacterMaps)
    }
}


class XsltInclude(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "include")


class XsltImport(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "import")


class XsltImportSchema(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "import-schema")


class XsltStripSpace(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "strip-space")


class XsltPreserveSpace(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "preserve-space")


class XsltDecimalFormat(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "decimal-format")


class XsltTemplate(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "template") {
    fun contextItem(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        `as`: String? = null,
        use: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltContextItem.() -> Unit) {
        val tag = initTag(XsltContextItem(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("as", `as`)
        if (use != null
            && use != "required"
            && use != "optional"
            && use != "absent") {
            throw RuntimeException("Invalid use: $use")
        }
        tag.maybe("use", use)
    }
    fun param(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        required: Boolean? = null,
        tunnel: Boolean? = null,
        static: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltParam.() -> Unit) {
        val tag = initTag(XsltParam(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("required", required)
        tag.maybe("tunnel", tunnel)
        tag.maybe("static", static)
    }
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltApplyTemplates(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "apply-templates")


class XsltMode(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "mode")


class XsltContextItem(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "context-item")


class XsltGlobalContextItem(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "global-context-item")


class XsltApplyImports(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "apply-imports")


class XsltNextMatch(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "next-match")


class XsltForEach(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "for-each") {
    fun sort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        lang: String? = null,
        order: String? = null,
        collation: String? = null,
        stable: String? = null,
        caseOrder: String? = null,
        dataType: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSort.() -> Unit) {
        val tag = initTag(XsltSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("lang", lang)
        tag.maybe("order", order)
        tag.maybe("collation", collation)
        tag.maybe("stable", stable)
        tag.maybe("case-order", caseOrder)
        tag.maybe("data-type", dataType)
    }
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltIterate(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "iterate") {
    fun param(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        required: Boolean? = null,
        tunnel: Boolean? = null,
        static: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltParam.() -> Unit) {
        val tag = initTag(XsltParam(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("required", required)
        tag.maybe("tunnel", tunnel)
        tag.maybe("static", static)
    }
    fun onCompletion(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnCompletion.() -> Unit) {
        val tag = initTag(XsltOnCompletion(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltNextIteration(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "next-iteration")


class XsltBreak(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "break") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltOnCompletion(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "on-completion") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltIf(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "if") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltChoose(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "choose") {
    fun `when`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWhen.() -> Unit) {
        val tag = initTag(XsltWhen(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun otherwise(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOtherwise.() -> Unit) {
        val tag = initTag(XsltOtherwise(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
}


class XsltWhen(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "when") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltOtherwise(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "otherwise") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltTry(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "try") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
    fun catch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        errors: String? = null,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCatch.() -> Unit) {
        val tag = initTag(XsltCatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("errors", errors)
        tag.maybe("select", select)
    }
}


class XsltCatch(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "catch") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltVariable(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "variable") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltParam(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "param") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltWithParam(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "with-param") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltCallTemplate(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "call-template")


class XsltAttributeSet(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "attribute-set")


class XsltFunction(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "function") {
    fun param(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        required: Boolean? = null,
        tunnel: Boolean? = null,
        static: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltParam.() -> Unit) {
        val tag = initTag(XsltParam(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("required", required)
        tag.maybe("tunnel", tunnel)
        tag.maybe("static", static)
    }
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltEvaluate(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "evaluate")


class XsltNamespaceAlias(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "namespace-alias")


class XsltElement(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "element") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltAttribute(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "attribute") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltText(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "text") {
    operator fun String.unaryPlus() {
        children.add(XsltTextElement(this))
    }
}


class XsltValueOf(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "value-of") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltDocument(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "document") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltProcessingInstruction(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "processing-instruction") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltNamespace(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "namespace") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltComment(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "comment") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltCopy(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "copy") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltCopyOf(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "copy-of")


class XsltSequence(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "sequence") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltWherePopulated(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "where-populated") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltOnEmpty(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "on-empty") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltOnNonEmpty(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "on-non-empty") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltNumber(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "number")


class XsltSort(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "sort") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltPerformSort(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "perform-sort") {
    fun sort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        lang: String? = null,
        order: String? = null,
        collation: String? = null,
        stable: String? = null,
        caseOrder: String? = null,
        dataType: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSort.() -> Unit) {
        val tag = initTag(XsltSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("lang", lang)
        tag.maybe("order", order)
        tag.maybe("collation", collation)
        tag.maybe("stable", stable)
        tag.maybe("case-order", caseOrder)
        tag.maybe("data-type", dataType)
    }
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltForEachGroup(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "for-each-group") {
    fun sort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        lang: String? = null,
        order: String? = null,
        collation: String? = null,
        stable: String? = null,
        caseOrder: String? = null,
        dataType: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSort.() -> Unit) {
        val tag = initTag(XsltSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("lang", lang)
        tag.maybe("order", order)
        tag.maybe("collation", collation)
        tag.maybe("stable", stable)
        tag.maybe("case-order", caseOrder)
        tag.maybe("data-type", dataType)
    }
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltMerge(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "merge") {
    fun mergeSource(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        name: String? = null,
        forEachItem: String? = null,
        forEachStream: String? = null,
        streamable: Boolean? = null,
        useAccumulators: String? = null,
        sortBeforeMerge: Boolean? = null,
        validation: String? = null,
        type: String? = null,
        forEachSource: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMergeSource.() -> Unit) {
        val tag = initTag(XsltMergeSource(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("name", name)
        tag.maybe("for-each-item", forEachItem)
        tag.maybe("for-each-stream", forEachStream)
        tag.maybe("streamable", streamable)
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("sort-before-merge", sortBeforeMerge)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("type", type)
        tag.maybe("for-each-source", forEachSource)
    }
    fun mergeAction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMergeAction.() -> Unit) {
        val tag = initTag(XsltMergeAction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
}


class XsltMergeSource(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "merge-source")


class XsltMergeKey(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "merge-key") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltMergeAction(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "merge-action") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltFork(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "fork") {
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
}


class XsltAnalyzeString(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "analyze-string") {
    fun matchingSubstring(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMatchingSubstring.() -> Unit) {
        val tag = initTag(XsltMatchingSubstring(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nonMatchingSubstring(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNonMatchingSubstring.() -> Unit) {
        val tag = initTag(XsltNonMatchingSubstring(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
}


class XsltMatchingSubstring(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "matching-substring") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltNonMatchingSubstring(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "non-matching-substring") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltSourceDocument(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "source-document") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltAccumulator(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "accumulator")


class XsltAccumulatorRule(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "accumulator-rule") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltKey(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "key") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltMap(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "map") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltMapEntry(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "map-entry") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltMessage(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "message") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltAssert(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "assert") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltFallback(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "fallback") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltResultDocument(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "result-document") {
    fun applyTemplates(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        mode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyTemplates.() -> Unit) {
        val tag = initTag(XsltApplyTemplates(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("mode", mode)
    }
    fun applyImports(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltApplyImports.() -> Unit) {
        val tag = initTag(XsltApplyImports(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun nextMatch(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextMatch.() -> Unit) {
        val tag = initTag(XsltNextMatch(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun forEach(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEach.() -> Unit) {
        val tag = initTag(XsltForEach(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun iterate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIterate.() -> Unit) {
        val tag = initTag(XsltIterate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun nextIteration(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNextIteration.() -> Unit) {
        val tag = initTag(XsltNextIteration(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `break`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltBreak.() -> Unit) {
        val tag = initTag(XsltBreak(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
    }
    fun `if`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltIf.() -> Unit) {
        val tag = initTag(XsltIf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
    }
    fun choose(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltChoose.() -> Unit) {
        val tag = initTag(XsltChoose(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun `try`(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        rollbackOutput: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltTry.() -> Unit) {
        val tag = initTag(XsltTry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("rollback-output", rollbackOutput)
    }
    fun variable(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        `as`: String? = null,
        static: Boolean? = null,
        visibility: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltVariable.() -> Unit) {
        val tag = initTag(XsltVariable(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
        tag.maybe("as", `as`)
        tag.maybe("static", static)
        if (visibility != null
            && visibility != "public"
            && visibility != "private"
            && visibility != "final"
            && visibility != "abstract") {
            throw RuntimeException("Invalid visibility: $visibility")
        }
        tag.maybe("visibility", visibility)
    }
    fun callTemplate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCallTemplate.() -> Unit) {
        val tag = initTag(XsltCallTemplate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
    }
    fun evaluate(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        xpath: String,
        `as`: String? = null,
        baseUri: String? = null,
        withParams: String? = null,
        contextItem: String? = null,
        namespaceContext: String? = null,
        schemaAware: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltEvaluate.() -> Unit) {
        val tag = initTag(XsltEvaluate(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("xpath")] = xpath
        tag.maybe("as", `as`)
        tag.maybe("base-uri", baseUri)
        tag.maybe("with-params", withParams)
        tag.maybe("context-item", contextItem)
        tag.maybe("namespace-context", namespaceContext)
        tag.maybe("schema-aware", schemaAware)
    }
    fun element(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltElement.() -> Unit) {
        val tag = initTag(XsltElement(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun attribute(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        namespace: String? = null,
        select: String? = null,
        separator: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAttribute.() -> Unit) {
        val tag = initTag(XsltAttribute(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("namespace", namespace)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun text(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltText.() -> Unit) {
        val tag = initTag(XsltText(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun valueOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        separator: String? = null,
        disableOutputEscaping: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltValueOf.() -> Unit) {
        val tag = initTag(XsltValueOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("separator", separator)
        tag.maybe("disable-output-escaping", disableOutputEscaping)
    }
    fun document(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltDocument.() -> Unit) {
        val tag = initTag(XsltDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun processingInstruction(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltProcessingInstruction.() -> Unit) {
        val tag = initTag(XsltProcessingInstruction(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun namespace(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        name: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNamespace.() -> Unit) {
        val tag = initTag(XsltNamespace(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("name")] = name
        tag.maybe("select", select)
    }
    fun comment(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltComment.() -> Unit) {
        val tag = initTag(XsltComment(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun copy(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        copyNamespaces: Boolean? = null,
        inheritNamespaces: Boolean? = null,
        useAttributeSets: String? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopy.() -> Unit) {
        val tag = initTag(XsltCopy(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("inherit-namespaces", inheritNamespaces)
        tag.maybe("use-attribute-sets", useAttributeSets)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun copyOf(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        copyAccumulators: Boolean? = null,
        copyNamespaces: Boolean? = null,
        type: String? = null,
        validation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltCopyOf.() -> Unit) {
        val tag = initTag(XsltCopyOf(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("copy-accumulators", copyAccumulators)
        tag.maybe("copy-namespaces", copyNamespaces)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
    }
    fun sequence(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSequence.() -> Unit) {
        val tag = initTag(XsltSequence(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun wherePopulated(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltWherePopulated.() -> Unit) {
        val tag = initTag(XsltWherePopulated(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun onEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnEmpty.() -> Unit) {
        val tag = initTag(XsltOnEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun onNonEmpty(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltOnNonEmpty.() -> Unit) {
        val tag = initTag(XsltOnNonEmpty(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun number(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        value: String? = null,
        select: String? = null,
        level: String? = null,
        count: String? = null,
        from: String? = null,
        format: String? = null,
        lang: String? = null,
        letterValue: String? = null,
        ordinal: String? = null,
        startAt: String? = null,
        groupingSeparator: String? = null,
        groupingSize: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltNumber.() -> Unit) {
        val tag = initTag(XsltNumber(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("value", value)
        tag.maybe("select", select)
        if (level != null
            && level != "single"
            && level != "multiple"
            && level != "any") {
            throw RuntimeException("Invalid level: $level")
        }
        tag.maybe("level", level)
        tag.maybe("count", count)
        tag.maybe("from", from)
        tag.maybe("format", format)
        tag.maybe("lang", lang)
        tag.maybe("letter-value", letterValue)
        tag.maybe("ordinal", ordinal)
        tag.maybe("start-at", startAt)
        tag.maybe("grouping-separator", groupingSeparator)
        tag.maybe("grouping-size", groupingSize)
    }
    fun performSort(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltPerformSort.() -> Unit) {
        val tag = initTag(XsltPerformSort(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
    }
    fun forEachGroup(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        groupBy: String? = null,
        groupAdjacent: String? = null,
        groupStartingWith: String? = null,
        groupEndingWith: String? = null,
        composite: Boolean? = null,
        collation: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltForEachGroup.() -> Unit) {
        val tag = initTag(XsltForEachGroup(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.maybe("group-by", groupBy)
        tag.maybe("group-adjacent", groupAdjacent)
        tag.maybe("group-starting-with", groupStartingWith)
        tag.maybe("group-ending-with", groupEndingWith)
        tag.maybe("composite", composite)
        tag.maybe("collation", collation)
    }
    fun merge(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMerge.() -> Unit) {
        val tag = initTag(XsltMerge(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun fork(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFork.() -> Unit) {
        val tag = initTag(XsltFork(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun analyzeString(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String,
        regex: String,
        flags: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAnalyzeString.() -> Unit) {
        val tag = initTag(XsltAnalyzeString(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("select")] = select
        tag.attributes[QName("regex")] = regex
        tag.maybe("flags", flags)
    }
    fun sourceDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        href: String,
        useAccumulators: String? = null,
        type: String? = null,
        validation: String? = null,
        streamable: Boolean? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltSourceDocument.() -> Unit) {
        val tag = initTag(XsltSourceDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("href")] = href
        tag.maybe("use-accumulators", useAccumulators)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("streamable", streamable)
    }
    fun map(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMap.() -> Unit) {
        val tag = initTag(XsltMap(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun mapEntry(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        key: String,
        select: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMapEntry.() -> Unit) {
        val tag = initTag(XsltMapEntry(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("key")] = key
        tag.maybe("select", select)
    }
    fun message(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        select: String? = null,
        terminate: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltMessage.() -> Unit) {
        val tag = initTag(XsltMessage(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("select", select)
        tag.maybe("terminate", terminate)
        tag.maybe("error-code", errorCode)
    }
    fun assert(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        test: String,
        select: String? = null,
        errorCode: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltAssert.() -> Unit) {
        val tag = initTag(XsltAssert(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.attributes[QName("test")] = test
        tag.maybe("select", select)
        tag.maybe("error-code", errorCode)
    }
    fun fallback(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltFallback.() -> Unit) {
        val tag = initTag(XsltFallback(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
    }
    fun resultDocument(
        vocabularyPrefix: String = vPrefix,
        vocabularyNamespace: String = vNamespace,
        format: String? = null,
        href: String? = null,
        type: String? = null,
        validation: String? = null,
        method: String? = null,
        allowDuplicateNames: String? = null,
        buildTree: String? = null,
        byteOrderMark: String? = null,
        cdataSectionElements: String? = null,
        doctypePublic: String? = null,
        doctypeSystem: String? = null,
        encoding: String? = null,
        escapeUriAttributes: String? = null,
        htmlVersion: String? = null,
        includeContentType: String? = null,
        indent: String? = null,
        itemSeparator: String? = null,
        jsonNodeOutputMethod: String? = null,
        mediaType: String? = null,
        normalizationForm: String? = null,
        omitXmlDeclaration: String? = null,
        parameterDocument: String? = null,
        standalone: String? = null,
        suppressIndentation: String? = null,
        undeclarePrefixes: String? = null,
        useCharacterMaps: String? = null,
        outputVersion: String? = null,
        attributes: Map<QName,String> = mapOf(),
        ns: Map<String,String> = mapOf(),
        init: XsltResultDocument.() -> Unit) {
        val tag = initTag(XsltResultDocument(vocabularyPrefix, vocabularyNamespace), init)
        tag.attributes.putAll(attributes)
        tag.namespaces.putAll(ns)
        tag.maybe("format", format)
        tag.maybe("href", href)
        tag.maybe("type", type)
        if (validation != null
            && validation != "strict"
            && validation != "lax"
            && validation != "preserve"
            && validation != "strip") {
            throw RuntimeException("Invalid validation: $validation")
        }
        tag.maybe("validation", validation)
        tag.maybe("method", method)
        tag.maybe("allow-duplicate-names", allowDuplicateNames)
        tag.maybe("build-tree", buildTree)
        tag.maybe("byte-order-mark", byteOrderMark)
        tag.maybe("cdata-section-elements", cdataSectionElements)
        tag.maybe("doctype-public", doctypePublic)
        tag.maybe("doctype-system", doctypeSystem)
        tag.maybe("encoding", encoding)
        tag.maybe("escape-uri-attributes", escapeUriAttributes)
        tag.maybe("html-version", htmlVersion)
        tag.maybe("include-content-type", includeContentType)
        tag.maybe("indent", indent)
        tag.maybe("item-separator", itemSeparator)
        tag.maybe("json-node-output-method", jsonNodeOutputMethod)
        tag.maybe("media-type", mediaType)
        tag.maybe("normalization-form", normalizationForm)
        tag.maybe("omit-xml-declaration", omitXmlDeclaration)
        tag.maybe("parameter-document", parameterDocument)
        tag.maybe("standalone", standalone)
        tag.maybe("suppress-indentation", suppressIndentation)
        tag.maybe("undeclare-prefixes", undeclarePrefixes)
        tag.maybe("use-character-maps", useCharacterMaps)
        tag.maybe("output-version", outputVersion)
    }
}


class XsltOutput(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "output")


class XsltCharacterMap(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "character-map")


class XsltOutputCharacter(val vPrefix: String, val vNamespace: String): XsltTag(vPrefix, vNamespace, "output-character")


fun stylesheet(
    builder: SaxonTreeBuilder,
    documentUri: String? = null,
    vocabularyPrefix: String = "xsl",
    vocabularyNamespace: String = "http://www.w3.org/1999/XSL/Transform",
    id: String? = null,
    version: String = "3.0",
    defaultMode: String? = null,
    defaultValidation: String? = null,
    inputTypeAnnotations: String? = null,
    defaultCollation: String? = null,
    extensionElementPrefixes: String? = null,
    excludeResultPrefixes: String? = null,
    expandText: Boolean? = null,
    useWhen: String? = null,
    xpathDefaultNamespace: String? = null,
    attributes: Map<QName,String> = mapOf(),
    ns: Map<String,String> = mapOf(),
    init: XsltStylesheet.() -> Unit): XdmNode {
    val tag = XsltStylesheet(vocabularyPrefix, vocabularyNamespace)
    tag.init()
    tag.attributes.putAll(attributes)
    tag.namespaces.putAll(ns)
    tag.maybe("id", id)
    tag.attributes[QName("version")] = version
    tag.maybe("default-mode", defaultMode)
    if (defaultValidation != null
        && defaultValidation != "preserve"
        && defaultValidation != "strip") {
        throw RuntimeException("Invalid defaultValidation: $defaultValidation")
    }
    tag.maybe("default-validation", defaultValidation)
    if (inputTypeAnnotations != null
        && inputTypeAnnotations != "preserve"
        && inputTypeAnnotations != "strip"
        && inputTypeAnnotations != "unspecified") {
        throw RuntimeException("Invalid inputTypeAnnotations: $inputTypeAnnotations")
    }
    tag.maybe("input-type-annotations", inputTypeAnnotations)
    tag.maybe("default-collation", defaultCollation)
    tag.maybe("extension-element-prefixes", extensionElementPrefixes)
    tag.maybe("exclude-result-prefixes", excludeResultPrefixes)
    tag.maybe("expand-text", expandText)
    tag.maybe("use-when", useWhen)
    tag.maybe("xpath-default-namespace", xpathDefaultNamespace)
  builder.startDocument(if (documentUri == null) null else URI(documentUri))
    tag.render(builder)
    builder.endDocument()
    return builder.result
}
