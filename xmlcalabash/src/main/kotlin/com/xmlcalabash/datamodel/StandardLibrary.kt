package com.xmlcalabash.datamodel

import com.xmlcalabash.io.MediaType
import com.xmlcalabash.namespace.NsCx
import com.xmlcalabash.namespace.NsP
import com.xmlcalabash.namespace.NsXml
import com.xmlcalabash.namespace.NsXs
import net.sf.saxon.s9api.QName
import net.sf.saxon.s9api.XdmAtomicValue
import java.net.URI

// This source file is automatically generated from tools/library.xpl
// Do not edit this file by hand.

class StandardLibrary private constructor(builder: PipelineBuilder, private val stepConfig: InstructionConfiguration) {
    companion object {
        internal fun getInstance(builder: PipelineBuilder): StandardLibraryInstruction {
            val nodeContext = builder.stepConfig
                .with("p", NsP.namespace)
                .with("cx", NsCx.namespace)
                .with("xml", NsXml.namespace)
                .with("xs", NsXs.namespace)
                .with(Location(URI("https://xmlcalabash.com/library/library.xpl")))
            val localConfig = InstructionConfiguration(builder.stepConfig, nodeContext)
            val standardLibrary = StandardLibrary(builder, localConfig)
            val library = standardLibrary.create()
            library.findDeclarations()
            library.elaborateInstructions()
            return library
        }
    }

    private val library = StandardLibraryInstruction(builder, stepConfig)

    private fun create(): StandardLibraryInstruction {
        library.version = 3.1
        cxCacheAddDocument()
        cxCacheRemoveDocument()
        cxDefaultInput()
        cxDocument()
        cxEmpty()
        cxSink()
        cxExpression()
        cxGuard()
        cxInline()
        cxInputFilter()
        cxSelect()
        pAddAttribute()
        pAddXmlBase()
        pArchive()
        pArchiveManifest()
        pCastContentType()
        pCompare()
        pCompress()
        pCount()
        pCssFormatter()
        pDelete()
        pDirectoryList()
        pEncode()
        pError()
        pFileCopy()
        pFileCreateTempfile()
        pFileDelete()
        pFileInfo()
        pFileMkdir()
        pFileMove()
        pFileTouch()
        pFilter()
        pHash()
        pHttpRequest()
        pIdentity()
        pInsert()
        pIxml()
        pInvisibleXml()
        pJsonJoin()
        pJsonMerge()
        pLabelElements()
        pLoad()
        pMakeAbsoluteUris()
        pMarkdownToHtml()
        pMessage()
        pNamespaceDelete()
        pNamespaceRename()
        pOsExec()
        pOsInfo()
        pPack()
        pRename()
        pReplace()
        pSendMail()
        pSetAttributes()
        pSetProperties()
        pSink()
        pSleep()
        pSplitSequence()
        pStore()
        pStringReplace()
        pTextCount()
        pTextHead()
        pTextJoin()
        pTextReplace()
        pTextSort()
        pTextTail()
        pUnarchive()
        pUncompress()
        pUnwrap()
        pUuid()
        pValidateWithJsonSchema()
        pValidateWithNvdl()
        pValidateWithRelaxNg()
        pValidateWithSchematron()
        pValidateWithXmlSchema()
        pValidateWithDtd()
        pWrap()
        pWrapSequence()
        pWwwFormUrldecode()
        pWwwFormUrlencode()
        pXinclude()
        pXquery()
        pXslFormatter()
        pXslt()
        return library
    }

    private fun cxCacheAddDocument(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:cache-add-document")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun cxCacheRemoveDocument(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:cache-remove-document")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun cxDefaultInput(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:default-input")

        var input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")
        input = decl.input("default", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun cxDocument(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:document")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun cxEmpty(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:empty")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun cxSink(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:sink")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun cxExpression(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:expression")

        val input = decl.input("source", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("any")
        input.empty()

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun cxGuard(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:guard")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")
        input.empty()

        return decl
    }

    private fun cxInline(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:inline")

        val input = decl.input("source", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("any")
        input.empty()

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun cxInputFilter(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:input-filter")

        var input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")
        input = decl.input("default", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun cxSelect(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("cx:select")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun pAddAttribute(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:add-attribute")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")

        var option = decl.option(QName("match"))
        option.select = XProcExpression.select(stepConfig, "'/*'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option = decl.option(QName("attribute-name"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName")
        option.required = true
        option = decl.option(QName("attribute-value"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.required = true

        return decl
    }

    private fun pAddXmlBase(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:add-xml-base")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")

        var option = decl.option(QName("all"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("relative"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pArchive(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:archive")

        var input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")
        input = decl.input("manifest", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("xml")
        input.empty()
        input = decl.input("archive", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("any")
        input.empty()

        var output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")
        output = decl.output("report", primary=false, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("format"))
        option.select = XProcExpression.select(stepConfig, "'zip'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName")
        option = decl.option(QName("relative-to"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI?")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, item()*)?")

        return decl
    }

    private fun pArchiveManifest(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:archive-manifest")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("format"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName?")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, item()*)?")
        option = decl.option(QName("relative-to"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI?")
        option = decl.option(QName("override-content-types"))
        option.asType = stepConfig.typeUtils.parseSequenceType("array(array(xs:string))?")

        return decl
    }

    private fun pCastContentType(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:cast-content-type")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("content-type"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.required = true
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")

        return decl
    }

    private fun pCompare(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:compare")

        var input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("any")
        input = decl.input("alternate", primary=false, sequence=false)
        input.contentTypes = MediaType.parseList("any")

        var output = decl.output("result", primary=false, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")
        output = decl.output("differences", primary=false, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("method"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName?")
        option = decl.option(QName("fail-if-not-equal"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pCompress(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:compress")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("format"))
        option.select = XProcExpression.select(stepConfig, "'gzip'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName")
        option = decl.option(QName("serialization"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, item()*)?")

        return decl
    }

    private fun pCount(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:count")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        val option = decl.option(QName("limit"))
        option.select = XProcExpression.select(stepConfig, "0")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:integer")

        return decl
    }

    private fun pCssFormatter(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:css-formatter")

        var input = decl.input("source", primary=false, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")
        input = decl.input("stylesheet", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("text")
        input.empty()

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("content-type"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")

        return decl
    }

    private fun pDelete(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:delete")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text xml html")

        val option = decl.option(QName("match"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option.required = true

        return decl
    }

    private fun pDirectoryList(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:directory-list")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("path"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("detailed"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("max-depth"))
        option.select = XProcExpression.select(stepConfig, "'1'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("include-filter"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string*")
        option = decl.option(QName("exclude-filter"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string*")
        option = decl.option(QName("override-content-types"))
        option.asType = stepConfig.typeUtils.parseSequenceType("array(array(xs:string))?")

        return decl
    }

    private fun pEncode(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:encode")

        val input = decl.input("source", primary=true, sequence=false)

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("encoding"))
        option.select = XProcExpression.select(stepConfig, "'base64'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option = decl.option(QName("serialization"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")

        return decl
    }

    private fun pError(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:error")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("text xml")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        val option = decl.option(QName("code"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName")
        option.required = true

        return decl
    }

    private fun pFileCopy(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:file-copy")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("href"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("target"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("fail-on-error"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("overwrite"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pFileCreateTempfile(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:file-create-tempfile")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("href"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI?")
        option = decl.option(QName("suffix"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("prefix"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("delete-on-exit"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("fail-on-error"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pFileDelete(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:file-delete")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("href"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("recursive"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("fail-on-error"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pFileInfo(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:file-info")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("href"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("fail-on-error"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("override-content-types"))
        option.asType = stepConfig.typeUtils.parseSequenceType("array(array(xs:string))?")

        return decl
    }

    private fun pFileMkdir(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:file-mkdir")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("href"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("fail-on-error"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pFileMove(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:file-move")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("href"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("target"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("fail-on-error"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pFileTouch(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:file-touch")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("href"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("timestamp"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:dateTime?")
        option = decl.option(QName("fail-on-error"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pFilter(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:filter")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("text xml html json")

        val option = decl.option(QName("select"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XPathExpression")
        option.required = true

        return decl
    }

    private fun pHash(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:hash")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text xml html")

        var option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("value"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.required = true
        option = decl.option(QName("algorithm"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName")
        option.required = true
        option = decl.option(QName("match"))
        option.select = XProcExpression.select(stepConfig, "'/*/node()'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option = decl.option(QName("version"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")

        return decl
    }

    private fun pHttpRequest(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:http-request")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        var output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")
        output = decl.output("report", primary=false, sequence=false)
        output.contentTypes = MediaType.parseList("application/json")

        var option = decl.option(QName("href"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("method"))
        option.select = XProcExpression.select(stepConfig, "'GET'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("serialization"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("headers"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:string, xs:string)?")
        option = decl.option(QName("auth"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:string, item()+)?")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, item()*)?")
        option = decl.option(QName("assert"))
        option.select = XProcExpression.select(stepConfig, "'.?status-code lt 400'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")

        return decl
    }

    private fun pIdentity(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:identity")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun pInsert(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:insert")

        var input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")
        input = decl.input("insertion", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")

        var option = decl.option(QName("match"))
        option.select = XProcExpression.select(stepConfig, "'/*'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option = decl.option(QName("position"))
        option.select = XProcExpression.select(stepConfig, "'after'")
        option.values = listOf(XdmAtomicValue("first-child"), XdmAtomicValue("last-child"), XdmAtomicValue("before"), XdmAtomicValue("after"))

        return decl
    }

    private fun pIxml(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:ixml")

        var input = decl.input("grammar", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("text xml")
        input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("any -xml -html")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, item()*)?")
        option = decl.option(QName("fail-on-error"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pInvisibleXml(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:invisible-xml")

        var input = decl.input("grammar", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("text xml")
        input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("any -xml -html")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, item()*)?")
        option = decl.option(QName("fail-on-error"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pJsonJoin(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:json-join")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/json")

        val option = decl.option(QName("flatten-to-depth"))
        option.select = XProcExpression.select(stepConfig, "'0'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")

        return decl
    }

    private fun pJsonMerge(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:json-merge")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/json")

        var option = decl.option(QName("duplicates"))
        option.select = XProcExpression.select(stepConfig, "'use-first'")
        option.values = listOf(XdmAtomicValue("reject"), XdmAtomicValue("use-first"), XdmAtomicValue("use-last"), XdmAtomicValue("use-any"), XdmAtomicValue("combine"))
        option = decl.option(QName("key"))
        option.select = XProcExpression.select(stepConfig, "'concat(\"_\",\$p:index)'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XPathExpression")

        return decl
    }

    private fun pLabelElements(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:label-elements")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")

        var option = decl.option(QName("attribute"))
        option.select = XProcExpression.select(stepConfig, "'xml:id'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName")
        option = decl.option(QName("label"))
        option.select = XProcExpression.select(stepConfig, "'concat(\"_\",\$p:index)'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XPathExpression")
        option = decl.option(QName("match"))
        option.select = XProcExpression.select(stepConfig, "'*'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option = decl.option(QName("replace"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pLoad(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:load")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("href"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("content-type"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("document-properties"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, item()*)?")

        return decl
    }

    private fun pMakeAbsoluteUris(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:make-absolute-uris")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")

        var option = decl.option(QName("match"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option.required = true
        option = decl.option(QName("base-uri"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI?")

        return decl
    }

    private fun pMarkdownToHtml(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:markdown-to-html")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("text")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("html")

        val option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, item()*)?")

        return decl
    }

    private fun pMessage(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:message")

        val input = decl.input("source", primary=true, sequence=true)

        val output = decl.output("result", primary=true, sequence=true)

        var option = decl.option(QName("test"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("select"))
        option.asType = stepConfig.typeUtils.parseSequenceType("item()*")
        option.required = true

        return decl
    }

    private fun pNamespaceDelete(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:namespace-delete")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")

        val option = decl.option(QName("prefixes"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.required = true

        return decl
    }

    private fun pNamespaceRename(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:namespace-rename")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")

        var option = decl.option(QName("from"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI?")
        option = decl.option(QName("to"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI?")
        option = decl.option(QName("apply-to"))
        option.select = XProcExpression.select(stepConfig, "'all'")
        option.values = listOf(XdmAtomicValue("all"), XdmAtomicValue("elements"), XdmAtomicValue("attributes"))

        return decl
    }

    private fun pOsExec(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:os-exec")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        var output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")
        output = decl.output("error", primary=false, sequence=false)
        output.contentTypes = MediaType.parseList("any")
        output = decl.output("exit-status", primary=false, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("command"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.required = true
        option = decl.option(QName("args"))
        option.select = XProcExpression.select(stepConfig, "()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string*")
        option = decl.option(QName("cwd"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("result-content-type"))
        option.select = XProcExpression.select(stepConfig, "'text/plain'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option = decl.option(QName("error-content-type"))
        option.select = XProcExpression.select(stepConfig, "'text/plain'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option = decl.option(QName("path-separator"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("failure-threshold"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:integer?")
        option = decl.option(QName("serialization"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")

        return decl
    }

    private fun pOsInfo(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:os-info")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        return decl
    }

    private fun pPack(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:pack")

        var input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("text xml html")
        input = decl.input("alternate", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("text xml html")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("wrapper"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName")
        option.required = true
        option = decl.option(QName("attributes"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, xs:anyAtomicType)?")

        return decl
    }

    private fun pRename(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:rename")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")

        var option = decl.option(QName("match"))
        option.select = XProcExpression.select(stepConfig, "'/*'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option = decl.option(QName("new-name"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName")
        option.required = true

        return decl
    }

    private fun pReplace(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:replace")

        var input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")
        input = decl.input("replacement", primary=false, sequence=false)
        input.contentTypes = MediaType.parseList("text xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text xml html")

        val option = decl.option(QName("match"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option.required = true

        return decl
    }

    private fun pSendMail(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:send-mail")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("serialization"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("auth"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:string, item()+)?")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, item()*)?")

        return decl
    }

    private fun pSetAttributes(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:set-attributes")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")

        var option = decl.option(QName("match"))
        option.select = XProcExpression.select(stepConfig, "'/*'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option = decl.option(QName("attributes"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, xs:anyAtomicType)")
        option.required = true

        return decl
    }

    private fun pSetProperties(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:set-properties")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("properties"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)")
        option.required = true
        option = decl.option(QName("merge"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pSink(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:sink")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        return decl
    }

    private fun pSleep(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:sleep")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        val option = decl.option(QName("duration"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.required = true

        return decl
    }

    private fun pSplitSequence(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:split-sequence")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")

        var output = decl.output("matched", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")
        output = decl.output("not-matched", primary=false, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("initial-only"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("test"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XPathExpression")
        option.required = true

        return decl
    }

    private fun pStore(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:store")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("any")

        var output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")
        output = decl.output("result-uri", primary=false, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("href"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI")
        option.required = true
        option = decl.option(QName("serialization"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")

        return decl
    }

    private fun pStringReplace(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:string-replace")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text xml html")

        var option = decl.option(QName("match"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option.required = true
        option = decl.option(QName("replace"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XPathExpression")
        option.required = true

        return decl
    }

    private fun pTextCount(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:text-count")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("text")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        return decl
    }

    private fun pTextHead(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:text-head")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("text")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text")

        val option = decl.option(QName("count"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:integer")
        option.required = true

        return decl
    }

    private fun pTextJoin(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:text-join")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("text")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text")

        var option = decl.option(QName("separator"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("prefix"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("suffix"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("override-content-type"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")

        return decl
    }

    private fun pTextReplace(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:text-replace")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("text")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text")

        var option = decl.option(QName("pattern"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.required = true
        option = decl.option(QName("replacement"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.required = true
        option = decl.option(QName("flags"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")

        return decl
    }

    private fun pTextSort(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:text-sort")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("text")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text")

        var option = decl.option(QName("sort-key"))
        option.select = XProcExpression.select(stepConfig, "'.'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XPathExpression")
        option = decl.option(QName("order"))
        option.select = XProcExpression.select(stepConfig, "'ascending'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.values = listOf(XdmAtomicValue("ascending"), XdmAtomicValue("descending"))
        option = decl.option(QName("case-order"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option.values = listOf(XdmAtomicValue("upper-first"), XdmAtomicValue("lower-first"))
        option = decl.option(QName("lang"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:language?")
        option = decl.option(QName("collation"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("stable"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pTextTail(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:text-tail")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("text")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text")

        val option = decl.option(QName("count"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:integer")
        option.required = true

        return decl
    }

    private fun pUnarchive(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:unarchive")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("include-filter"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string*")
        option.specialType = stepConfig.typeUtils.parseSpecialType("RegularExpression")
        option = decl.option(QName("exclude-filter"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string*")
        option.specialType = stepConfig.typeUtils.parseSpecialType("RegularExpression")
        option = decl.option(QName("format"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName?")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, item()*)?")
        option = decl.option(QName("relative-to"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI?")
        option = decl.option(QName("override-content-types"))
        option.asType = stepConfig.typeUtils.parseSequenceType("array(array(xs:string))?")

        return decl
    }

    private fun pUncompress(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:uncompress")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("any")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("format"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName?")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("content-type"))
        option.select = XProcExpression.select(stepConfig, "'application/octet-stream'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")

        return decl
    }

    private fun pUnwrap(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:unwrap")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text xml html")

        val option = decl.option(QName("match"))
        option.select = XProcExpression.select(stepConfig, "'/*'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")

        return decl
    }

    private fun pUuid(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:uuid")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text xml html")

        var option = decl.option(QName("match"))
        option.select = XProcExpression.select(stepConfig, "'/*'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option = decl.option(QName("version"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:integer?")

        return decl
    }

    private fun pValidateWithJsonSchema(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:validate-with-json-schema")

        var input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("json")
        input = decl.input("schema", primary=false, sequence=false)
        input.contentTypes = MediaType.parseList("json")

        var output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("json")
        output = decl.output("report", primary=false, sequence=true)
        output.contentTypes = MediaType.parseList("xml json")

        var option = decl.option(QName("assert-valid"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("default-version"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("report-format"))
        option.select = XProcExpression.select(stepConfig, "'xvrl'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")

        return decl
    }

    private fun pValidateWithNvdl(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:validate-with-nvdl")

        var input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")
        input = decl.input("nvdl", primary=false, sequence=false)
        input.contentTypes = MediaType.parseList("xml")
        input = decl.input("schemas", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("text xml")
        input.empty()

        var output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")
        output = decl.output("report", primary=false, sequence=true)
        output.contentTypes = MediaType.parseList("xml json")

        var option = decl.option(QName("assert-valid"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("report-format"))
        option.select = XProcExpression.select(stepConfig, "'xvrl'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")

        return decl
    }

    private fun pValidateWithRelaxNg(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:validate-with-relax-ng")

        var input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")
        input = decl.input("schema", primary=false, sequence=false)
        input.contentTypes = MediaType.parseList("text xml")

        var output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")
        output = decl.output("report", primary=false, sequence=true)
        output.contentTypes = MediaType.parseList("xml json")

        var option = decl.option(QName("dtd-attribute-values"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("dtd-id-idref-warnings"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("assert-valid"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("report-format"))
        option.select = XProcExpression.select(stepConfig, "'xvrl'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")

        return decl
    }

    private fun pValidateWithSchematron(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:validate-with-schematron")

        var input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")
        input = decl.input("schema", primary=false, sequence=false)
        input.contentTypes = MediaType.parseList("xml")

        var output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")
        output = decl.output("report", primary=false, sequence=true)
        output.contentTypes = MediaType.parseList("xml json")

        var option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("phase"))
        option.select = XProcExpression.select(stepConfig, "'#DEFAULT'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option = decl.option(QName("assert-valid"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("report-format"))
        option.select = XProcExpression.select(stepConfig, "'svrl'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")

        return decl
    }

    private fun pValidateWithXmlSchema(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:validate-with-xml-schema")

        var input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")
        input = decl.input("schema", primary=false, sequence=true)
        input.contentTypes = MediaType.parseList("xml")

        var output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")
        output = decl.output("report", primary=false, sequence=true)
        output.contentTypes = MediaType.parseList("xml json")

        var option = decl.option(QName("use-location-hints"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("try-namespaces"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("assert-valid"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("mode"))
        option.select = XProcExpression.select(stepConfig, "'strict'")
        option.values = listOf(XdmAtomicValue("strict"), XdmAtomicValue("lax"))
        option = decl.option(QName("version"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option = decl.option(QName("report-format"))
        option.select = XProcExpression.select(stepConfig, "'xvrl'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")

        return decl
    }

    private fun pValidateWithDtd(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:validate-with-dtd")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        var output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")
        output = decl.output("report", primary=false, sequence=true)
        output.contentTypes = MediaType.parseList("xml json")

        var option = decl.option(QName("report-format"))
        option.select = XProcExpression.select(stepConfig, "'xvrl'")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option = decl.option(QName("serialization"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("assert-valid"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pWrap(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:wrap")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("wrapper"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName")
        option.required = true
        option = decl.option(QName("match"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XSLTSelectionPattern")
        option.required = true
        option = decl.option(QName("group-adjacent"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XPathExpression")
        option = decl.option(QName("attributes"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, xs:anyAtomicType)?")

        return decl
    }

    private fun pWrapSequence(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:wrap-sequence")

        val input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("text xml html")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("application/xml")

        var option = decl.option(QName("wrapper"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName")
        option.required = true
        option = decl.option(QName("group-adjacent"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")
        option.specialType = stepConfig.typeUtils.parseSpecialType("XPathExpression")
        option = decl.option(QName("attributes"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName, xs:anyAtomicType)?")

        return decl
    }

    private fun pWwwFormUrldecode(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:www-form-urldecode")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("application/json")

        val option = decl.option(QName("value"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string")
        option.required = true

        return decl
    }

    private fun pWwwFormUrlencode(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:www-form-urlencode")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("text/plain")

        val option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:string,xs:anyAtomicType+)")
        option.required = true

        return decl
    }

    private fun pXinclude(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:xinclude")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml html")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("xml html")

        var option = decl.option(QName("fixup-xml-base"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")
        option = decl.option(QName("fixup-xml-lang"))
        option.select = XProcExpression.select(stepConfig, "false()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean")

        return decl
    }

    private fun pXquery(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:xquery")

        var input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")
        input = decl.input("query", primary=false, sequence=false)
        input.contentTypes = MediaType.parseList("text xml")

        val output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("version"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")

        return decl
    }

    private fun pXslFormatter(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:xsl-formatter")

        val input = decl.input("source", primary=true, sequence=false)
        input.contentTypes = MediaType.parseList("xml")

        val output = decl.output("result", primary=true, sequence=false)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("content-type"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")

        return decl
    }

    private fun pXslt(): DeclareStepInstruction {
        val decl = library.declareAtomicStep()
        decl._type = stepConfig.typeUtils.parseQName("p:xslt")

        var input = decl.input("source", primary=true, sequence=true)
        input.contentTypes = MediaType.parseList("any")
        input = decl.input("stylesheet", primary=false, sequence=false)
        input.contentTypes = MediaType.parseList("xml")

        var output = decl.output("result", primary=true, sequence=true)
        output.contentTypes = MediaType.parseList("any")
        output = decl.output("secondary", primary=false, sequence=true)
        output.contentTypes = MediaType.parseList("any")

        var option = decl.option(QName("parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("static-parameters"))
        option.asType = stepConfig.typeUtils.parseSequenceType("map(xs:QName,item()*)?")
        option = decl.option(QName("global-context-item"))
        option.asType = stepConfig.typeUtils.parseSequenceType("item()?")
        option = decl.option(QName("populate-default-collection"))
        option.select = XProcExpression.select(stepConfig, "true()")
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:boolean?")
        option = decl.option(QName("initial-mode"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName?")
        option = decl.option(QName("template-name"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:QName?")
        option = decl.option(QName("output-base-uri"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:anyURI?")
        option = decl.option(QName("version"))
        option.asType = stepConfig.typeUtils.parseSequenceType("xs:string?")

        return decl
    }
}
